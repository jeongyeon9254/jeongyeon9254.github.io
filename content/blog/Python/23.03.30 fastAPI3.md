---
title: 'fastApi (3)'
date: 2023-03-30
category: 'python'
draft: false
---

# fastAPI doc 자습

fastAPI 에 대해 간단하게 알아보았으며, 공식문서를 통해 fastAPI를 배워보겠습니다.

<br>

# 경로 매개변수

### 매개변수 타입지정

매개변수를 받아 반환할수 있고, 해당 매개변수에 타입을 지정할 수 있습니다.

```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/user/{id}")
async def user_id(id: int):  # id 의 타입은 숫자형입니다.
    return {"user_id": id}
```

만약 user/{id} 와 user/me를 함께 사용해야 할 경우

user/me함수를 먼저 선언해주어야 합니다.

```python
from fastapi import FastAPI

app = FastAPI()


@app.get("/uses/me")
async def get_user_me():    # 해당함수가 먼저 선언되어야 합니다.
    return {"user_id": "the current user"}


@app.get("/user/{id}")
async def user_id(id: int):
    return {"user_id": id}
```

### 고정 상수값 지정

만약 매개변수값에 대해 고정적인 처리를 하고싶다면, enum클래스를 생성하여 고정적인 처리를 할수 있습니다.

```python
from enum import Enum

from fastapi import FastAPI


class ModelName(str, Enum):     # enum 클래스를 선언합니다.
    alexnet = "alexnet"         # TS 의 인터페이스와 타입을 함께 선언하는 느낌입니다.
    resnet = "resnet"
    lenet = "lenet"


app = FastAPI()


@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):     # 이경우 docs에서 ModelName클래스의 값이 정의되어 표시됩니다.
    if model_name is ModelName.alexnet:
        return {"model_name": model_name, "message": "Deep Learning FTW!"}

    if model_name.value == "lenet":
        return {"model_name": model_name, "message": "LeCNN all the images"}

    return {"model_name": model_name, "message": "Have some residuals"}
```

# 쿼리 매개변수

경로 매개변수의 일부가 아닌 다른 함수 매개변수를 선언할 때, "쿼리" 매개변수로 자동 해석합니다.

쿼리 매개변수는 경로에서 고정된 부분이 아니기 때문에 선택적일 수 있고 기본값을 가질 수 있습니다.

```python
from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}")
async def read_item(item_id: str, q: Union[str, None] = None, short: bool = False):
    # q = None 로 기본값을 주었기 때문에 필수값이 아니며, short는 필수값입니다.
    item = {"item_id": item_id}
    if q:
        item.update({"q": q})
    if not short:
        item.update(
            {"description": "This is an amazing item that has a long description"}
        )
    return item
```

# Request Body

보통 GET 요청이 아닌, POST/DELETE/PUT 요청의 경우 리퀘스트 바디에 요청값을 보냅니다. (필수는 아닙니다)

이때 pydantic의 BaseModel을 이용하여, 데이터모델을 상속하는 클래스를 만듭니다.

```python
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None # 필수값은 아닙니다.
    price: float
    tax: Union[float, None] = None # 필수값은 아닙니다.

# 파이썬 타입힌트만으로도 fastAPI는 다음과 같은 일을 수행합니다.
# 요청 본문을 JSON으로 읽습니다.
# 해당유형을 반환해줄 수 있습니다.
# 데이터를 검증합니다.
# 매개변수 및 파라미터에서 받은 데이터를 반환합니다.

app = FastAPI()


@app.post("/items/{item_id}")
async def create_item(item_count:int, item: Item):      # 매개변수값을 반환값에 포함합니다.
    item_dict = item.dict()
    if item.tax:
        price_with_tax = (item.price + item.tax)*item_count
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict
```

# 쿼리 매개변수와 문자열 유효성 검사

```py
from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/")
async def read_items(q: Union[str, None] = None):
    results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]}
    if q:
        results.update({"q": q})
    return results
```

위와 같은 코드에서 만약 매개변수 'q'에 대해 문자열이 50자를 초과하지 않도록 제한하고 싶다면 어떻게 해야 할까요?

```py
from fastapi import FastAPI, Query
from typing_extensions import Annotated

...
# 매개변수 q에 타입을 Annotated으로 감싸줍니다.
async def read_items(q: Annotated[Union[str, None], Query(max_length=50)] = None):
# 또한 다음과 같습니다.
async def read_items(q: Union[str, None] = Query(default=None, max_length=50)):
# 다음과 같으며 가장 권장하는 방식입니다.
async def read_items(q: Annotated[str, Query(max_length=50)]):
# 해당 어노테이티드로 매개변수 'q'에 문자열 길이를 제한할 수 있습니다.
# max_length 말고도 정규식등 다양한 옵션설정이 가능합니다.

# 해당값이 필수값인경우 리터럴을 이용해 표현할 수 있습니다.
async def read_items(q: Annotated[str, Query(min_length=3)] = ...):

# 물론 Required를 이용해 표현할 수 있습니다.
from pydantic import Required
from typing_extensions import Annotated

...
async def read_items(q: Annotated[str, Query(min_length=3)] = Required):
```

# 숫자 유효성 검사

문자열뿐 아니라 숫자형에 대해서도 유효성 검사를 할 수 있습니다.

```py
from fastapi import FastAPI, Path

app = FastAPI()

# ge 는 크거나 같다는 뜻으로 item_id 가 1보다 크거나 같아야 한다는 뜻입니다.
# 외에 gt,ge,lt,le 가 있습니다.
@app.get("/items/{item_id}")
async def read_items(
    *, item_id: int = Path(title="The ID of the item to get", ge=1), q: str
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results
```

# python enum

파이썬은 버전 3.4부터 다른 언어들 처럼 enum(enumeration, 이넘) 타입을 지원하고 있습니다.

enum은 서로 관련이 있는 상수의 집합을 정의할 때 사용됩니다.

```py
# 일반적으로 클래스에 상속하여 사용합니다.
# key와 value쌍으로 만들수 있습니다.
from enum import Enum

class Skill(Enum):
    HTML = 1
    CSS = 2
    JS = 3

# 자주 사용하지는 않지만 함수형으로도 정의할수 있습니다.
>>> Skill = Enum("Skill", "HTML CSS JS")
>>> list(Skill)
[<Skill.HTML: 1>, <Skill.CSS: 2>, <Skill.JS: 3>]

# 또한 auto()를 통해 숫자 1부터 자동으로 value에 할당할 수 있습니다.
from enum import Enum, auto

class Skill(Enum):
    HTML = auto()
    CSS = auto()
    JS = auto()

# enum내의 _generate_next_value_ 매서드를 오버라이드해서 다른값을 자동으로 할당할수 있습니다.
# name 의 경우 key값과 같은 value값을 가질 수 있습니다.
from enum import Enum, auto

class Skill(Enum):
    def _generate_next_value_(name, start, count, last_values):
        return name

    HTML = auto()
    CSS = auto()
    JS = auto()

# enum을 사용할 때 name이나 value를 사용해야 반드시 제대로된 key,value값이 나오는데,
# mixin을 이용해 str을 확장하는 클래스를 만들고, 해당 클래스를 상속해 사용할 enum클래스를 만듭니다.
# 아래와같이 enum또한 다른 클래스처럼 상속과 확장이 가능합니다.
class StrEnum(str, Enum):
    def _generate_next_value_(name, start, count, last_values):
        return name # value값을 key값과 같게끔 이름을 반환합니다.

    def __repr__(self):
        return self.name

    def __str__(self):
        return self.name

class Skill(StrEnum):
    HTML = auto()
    CSS = auto()
    JS = auto()

>>> Skill.HTML == 'HTML'
True
>>> isinstance(Skill.HTML, str)
True

# 근데 이렇게 쓸 바에야 차라리 함수로 상수를 리턴한다는 의견도 있다니, 취향껏 쓰시면 되지않을까 싶습니다.
def get_const():
    return 1000
>>> print(get_const()) # 1000

# 참고로 상수에 대한 타입인 파이널도 있습니다.
from typing import Final

const: Final[float] = 1000
```

# 파이댄틱

그리고 데코레이터, 자바에 어노테이션과 파이썬의 어노테이션은 다른의미
